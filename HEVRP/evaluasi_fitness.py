# -*- coding: utf-8 -*-
"""evaluasi fitness.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15i61NcIQdKh1so6_knrd14aKToMBp9EJ

# **NILAI FITNESS ATAU FUNGSI OBJEKTIF**
"""

def fitness_evaluation(whale, nodes, fleet):
    routes = get_feasible_route(whale, nodes, fleet)

    total_distance = 0.0
    DISTANCE_MATRIX = distance_matrix(nodes)

    for route in routes:
        _route = [0] + route + [0]
        for current in range(1, len(_route)):
            prev_node = _route[current - 1]
            cur_node  = _route[current]
            total_distance += DISTANCE_MATRIX[prev_node][cur_node]

    return total_distance

"""# **FUNGSI KENDALA**

**MENENTUKAN URUTAN KUNJUNGAN PELANGGAN BERDASARKAN POSISI PAUS**
"""

def whale_2_route(whale):
    sorted_asc = sorted(whale, key=float)
    route = []

    if len(sorted_asc) > len(set(sorted_asc)):
        print("problem")

    index_customer = get_customer(nodes)
    for value in whale:
        index = sorted_asc.index(value)
        route.append((index + index_cust[0]))

    return route

"""**MENGINISIALISASIKAN TITIK PELANGGAN DENGAN MENPERHATIKAN FUNGSI KENDALA**"""

def get_feasible_route(whale, nodes, fleet):
    feasible_route = []
    route = whale_2_route(whale)

    # Retrieve necessary instance parameters
    STATION_LIST = station_list(nodes)
    DISTANCE_MATRIX = distance_matrix(nodes)
    DUE_TIME = due_time(nodes)
    READY_TIME = ready_time(nodes)
    SERVICE_TIME = service_time(nodes)
    LOAD_CAPACITY = load_capacity(fleet)
    BATTERY_CAPACITY = battery_capacity(fleet)
    ENERGY_CONSUMPTION = energy_cons_rate(fleet)
    VELOCITY = velocity(fleet)
    SWAPPING_TIME = swapping_time(fleet)

    # Initialize a sub-route and related variables
    sub_route = []
    ev = 0
    capacity_left = MAX_CAPACITY[ev]
    energy_left = BATTERY_CAPACITY[ev]
    elapsed_time = 0
    prev_node = 0

    # Iterate through customer nodes and insert them into feasible sub-routes
    for node in route:
        assigned = False
        while not assigned:
            # Calculate remaining capacity and energy after inserting the current customer node
            updated_capacity_left = capacity_left - nodes[node]['demand']
            updated_energy_left = energy_left - ENERGY_CONSUMPTION[ev] * DISTANCE_MATRIX[prev_node][node]
            arrival_time = elapsed_time + DISTANCE_MATRIX[prev_node][node] / VELOCITY[ev] + SERVICE_TIME[prev_node]
            waiting_time = max(0, READY_TIME[node] - arrival_time)
            updated_elapsed_time = waiting_time + arrival_time
            if is_feasible(sub_route + [node], updated_capacity_left, updated_energy_left, updated_elapsed_time, ev, DISTANCE_MATRIX, ENERGY_CONSUMPTION, DUE_TIME, STATION_LIST):
                # Add the customer node to the sub-route and update related variables
                sub_route.append(node)
                capacity_left = updated_capacity_left
                energy_left = updated_energy_left
                elapsed_time = updated_elapsed_time
                prev_node = node
                assigned = True
            else:
                # Determine the reason for infeasibility and take appropriate action
                if(prev_node == 0):
                    nearest_station = find_nearest_station(node, DISTANCE_MATRIX, STATION_LIST)
                    sub_route.append(nearest_station)
                    elapsed_time = elapsed_time + DISTANCE_MATRIX[prev_node][nearest_station] / VELOCITY[ev] + SWAPPING_TIME[ev]
                    prev_node = nearest_station
                    continue
                nearest_station = find_nearest_station(prev_node, DISTANCE_MATRIX, STATION_LIST)
                updated_energy_left = BATTERY_CAPACITY[ev] - ENERGY_CONSUMPTION[ev] * DISTANCE_MATRIX[nearest_station][node]
                updated_elapsed_time = updated_elapsed_time + DISTANCE_MATRIX[nearest_station][node] / VELOCITY[ev] + SWAPPING_TIME[ev]

                result = handle_infeasible_route(feasible_route, sub_route, nearest_station, updated_capacity_left,
                                                 updated_energy_left, updated_elapsed_time, energy_left, ev, prev_node, node, MAX_CAPACITY,
                                                 BATTERY_CAPACITY, DISTANCE_MATRIX, ENERGY_CONSUMPTION, DUE_TIME, STATION_LIST)
                feasible_route, sub_route, ev, capacity_left, energy_left, elapsed_time, prev_node, assigned = result.values()

    # Handle the remaining sub_route, if any
    if sub_route != []:
        if energy_left >= ENERGY_CONSUMPTION[ev] * DISTANCE_MATRIX[sub_route[-1]][0]:
            feasible_route.append(sub_route)
        else:
            nearest_station = find_nearest_station(sub_route[-1], DISTANCE_MATRIX, STATION_LIST)
            sub_route.append(nearest_station)
            feasible_route.append(sub_route)

    return feasible_route

"""**MEMERIKSA APAKAH RUTE MEMENUHI KENDALA WAKTU, MUATAN, DAN DAYA BATERAI**"""

def is_feasible(route, capacity_left, energy_left, elapsed_time, ev, distance_matrix, energy_consumption, due_time, station_list):
    current = route[-1]
    nearest_station = find_nearest_station(current, distance_matrix, station_list)
    depot = 0

    # Calculate the energy required to reach the nearest station or the depot
    energy_required = energy_consumption[ev] * min(distance_matrix[current][nearest_station], distance_matrix[current][depot])
    due_time = due_time[current]

    if capacity_left >= 0 and elapsed_time <= due_time and energy_left >= 0 and energy_left >= energy_required:
        return True
    else:
        return False

"""**MEMPERBAIKI RUTE KENDARAAN JIKA TIDAK MEMENUHI KENDALA**"""

def handle_infeasible_route(route, sub_route, nearest_station, updated_capacity_left, updated_energy_left, updated_elapsed_time, energy_left, ev, prev_node, node, MAX_CAPACITY, BATTERY_CAPACITY, DISTANCE_MATRIX, ENERGY_CONSUMPTION, DUE_TIME, STATION_LIST):
    assigned = False
    if updated_capacity_left < 0 and updated_elapsed_time > DUE_TIME[node]:
        # Handle the case where vehicle capacity and time window is exhausted
        if energy_left >= ENERGY_CONSUMPTION[ev] * DISTANCE_MATRIX[prev_node][0]:
            route.append(sub_route)
        else:
            sub_route.append(nearest_station)
            route.append(sub_route)
    else:
        # Handle the case where vehicle energy is insufficient
        if energy_left >= ENERGY_CONSUMPTION[ev] * max(DISTANCE_MATRIX[prev_node][nearest_station], DISTANCE_MATRIX[prev_node][0]):
            # Starting from the prev_node, the EV has enough battery to reach the nearest charging station and return to the depot.
            sub_route.append(nearest_station)
            if is_feasible(sub_route + [node], updated_capacity_left, updated_energy_left, updated_elapsed_time, ev, DISTANCE_MATRIX, ENERGY_CONSUMPTION, DUE_TIME, STATION_LIST):
                sub_route.append(node)
                capacity_left = updated_capacity_left
                energy_left = updated_energy_left
                elapsed_time = updated_elapsed_time
                prev_node = node
                assigned = True
                return {'route': route, 'sub_route': sub_route, 'ev': ev, 'capacity_left': capacity_left, 'energy_left': energy_left, 'elapsed_time':elapsed_time, 'prev_node': prev_node, 'assigned': assigned}
            else:
                sub_route.pop()
                route.append(sub_route)
        elif energy_left >= ENERGY_CONSUMPTION[ev] * DISTANCE_MATRIX[prev_node][nearest_station]:
            # Starting from the prev_node, the EV doesn't have enough battery to return to the depot, but can reach the nearest charging station.
            sub_route.append(nearest_station)
            if is_feasible(sub_route + [node], updated_capacity_left, updated_energy_left, updated_elapsed_time, ev, DISTANCE_MATRIX, ENERGY_CONSUMPTION, DUE_TIME, STATION_LIST):
                sub_route.append(node)
                capacity_left = updated_capacity_left
                energy_left = updated_energy_left
                elapsed_time = updated_elapsed_time
                prev_node = node
                assigned = True
                return {'route': route, 'sub_route': sub_route, 'ev': ev, 'capacity_left': capacity_left, 'energy_left': energy_left, 'elapsed_time':elapsed_time, 'prev_node': prev_node, 'assigned': assigned}
            else:
                route.append(sub_route)
        else:
            # Starting from the prev_node, the EV cannot reach the nearest station or return to the depot
            route.append(sub_route)

    sub_route = []
    ev += 1
    if ev >= len(MAX_CAPACITY):
        ev = 0
    capacity_left = MAX_CAPACITY[ev]
    energy_left = BATTERY_CAPACITY[ev]
    elapsed_time = 0
    prev_node = 0

    return {'route': route, 'sub_route': sub_route, 'ev': ev, 'capacity_left': capacity_left, 'energy_left': energy_left, 'elapsed_time':elapsed_time, 'prev_node': prev_node, 'assigned': assigned}

"""**MENENTUKAN STASIUN PENGISIAN BATERAI TERDEKAT**"""

def find_nearest_station(node_no, distance_matrix, station_list):
    return int(min(station_list, key=lambda station_no: distance_matrix[int(node_no)][int(station_no)]))